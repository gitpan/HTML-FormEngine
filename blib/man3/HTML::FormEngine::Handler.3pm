.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FormEngine::Handler 3"
.TH FormEngine::Handler 3 "2003-03-03" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
HTML::FormEngine::Handler \- FormEngine template handler
.SH "HANDLERS"
.IX Header "HANDLERS"
.Sh "default"
.IX Subsection "default"
The default handler is called if the named handler doesn't exist.
.PP
With help of the default handler one can nest templates. It expects the name,
with which it was called, to be the name of an template.
It then reads in this template and processes it. The resulting code is returned.
.Sh "checked"
.IX Subsection "checked"
This handler is used in the \fIselect\fR, \fIradio\fR and \fIcheck\fR template.
It first argument is returned if the field was selected. If this
argument is not defined, \fIchecked\fR is returned. If the field wasn't
selected, \s-1NULL\s0 is returned.
.PP
The second argument is the name of the variable in which the value
of the field is defined which is submitted if the field was selected.
By default the value of this argument is \fI\s-1OPT_VAL\s0\fR.
.PP
The third argument contains the name of the variable in which the name
of the field is stored. With the help of this variable the submitted value
of the field is read in to be compared with the value which the field should
have if it was selected. So the handler can determine wether the field
was selected or not. By default this argument is \fI\s-1NAME\s0\fR.
.PP
The fourth and last argument contains the name of the variable in which 
the visible name of the field is stored.
The value of this variable is read in to distinguish selection lists. We can expect
this value to be unique in the same list.
By default this argument is \fI\s-1OPTION\s0\fR.
.PP
Normally the only important argument is the first one. The others can be important
if you want to change variable names.
.Sh "checked_uniq"
.IX Subsection "checked_uniq"
This handler is designed for checkboxes. With checked_uniq, you only
have to define one name for all options, but you can't use this name
again.
.PP
The first argument defines the value, which should be returned if a
certain option was submitted. By default this is 'checked'.
.PP
The second argument defines the name of the variable in which the
option values are stored (default: \s-1OPT_VAL\s0).
.PP
The third argument defines the name of the variable which defines the
field name (default: \s-1NAME\s0).
.Sh "confirm_checked"
.IX Subsection "confirm_checked"
This is a confirm handler. It returns the title of an option if the
option was submitted. Therefore the \f(CW\*(C`checked\*(C'\fR handler is called, with
the option title as first argument.
.PP
The first argument defines the name of the variable in which the
option values are stored (default: \s-1OPT_VAL\s0).  The second argument
defines the name of the variable which defines the field name
(default: \s-1NAME\s0).
.PP
The third argument defines the name of the variable which stores the
option titles (default: \s-1OPTION\s0).
.Sh "confirm_checked_uniq"
.IX Subsection "confirm_checked_uniq"
This handler is very simalar to \f(CW\*(C`confirm_checked\*(C'\fR. The only
difference is that it calls \f(CW\*(C`checked_uniq\*(C'\fR instead of \f(CW\*(C`checked\*(C'\fR.
.Sh "value"
.IX Subsection "value"
This handler returns the value of the field.
.PP
The first argument defines the value which should be returned if the
value is empty. By default this is undef.
.PP
If the second argument is true (1), the value, which was last returned
for this field name, will be returned again instead of trying to fetch
the next value.
.PP
The third argument is used to tell the handler the name of the
variable in which the field name is stored.  By default this is
\&\fI\s-1NAME\s0\fR.
.PP
If the form wasn't submitted, the fields default value is returned.
.SH "error"
.IX Header "error"
The first argument sets the name of the variable in which the error checks are
set. By default this is \fI\s-1ERROR\s0\fR.
.PP
The second argument sets the name of the variable in which the fields name
is stored. By default this is \fI\s-1NAME\s0\fR.
.PP
The handler calls the defined error checks until an error message is returned
or all checks were called. If it retrieves an error message it returns this message,
else \s-1NULL\s0 is returned.
.Sh "gettext"
.IX Subsection "gettext"
The arguments, given to this handler, are passed through gettext and
then joined together with a spacing blank inbetween. The resulting
string is returned.
.SH "WRITING A HANDLER"
.IX Header "WRITING A HANDLER"
.Sh "Design"
.IX Subsection "Design"
In general, a handler has the following structure:
.PP
.Vb 5
\&   sub myhandler {
\&     my($self,$callname,@args) = @_;
\&     # ... some code ... #
\&     return $res;
\&   }
.Ve
.PP
\&\f(CW$self\fR contains a reference to the FormEngine object.
.PP
\&\f(CW$callname\fR contains the name or synonym which was used to call the handler.
So it is possible to use the same handler for several, similar jobs.
.PP
\&\f(CW@args\fR contains the arguments which were passed to the handler (see Skin.pm).
.Sh "Install"
.IX Subsection "Install"
You have to edit Config.pm to make your handler available.
