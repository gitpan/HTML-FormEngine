.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FormEngine 3"
.TH FormEngine 3 "2003-03-02" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
HTML::FormEngine \- create,validate and control html/xhtml forms
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
.Sh "Perl Version"
.IX Subsection "Perl Version"
.Vb 1
\&        5.004
.Ve
.Sh "Standard Modules"
.IX Subsection "Standard Modules"
.Vb 1
\&        none
.Ve
.Sh "Nonstandard Modules"
.IX Subsection "Nonstandard Modules"
.Vb 4
\&        Clone 0.13
\&        Hash::Merge 0.07
\&        Locale::gettext 1.01
\&        Date::Pcalc 1.2
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Sh "Example Code"
.IX Subsection "Example Code"
.Vb 1
\&       #!/usr/bin/perl
.Ve
.PP
.Vb 5
\&       use strict;
\&       use CGI;
\&       use HTML::FormEngine;
\&       #use POSIX; # for setlocale
\&       #setlocale(LC_MESSAGES, 'german'); # for german error messages
.Ve
.PP
.Vb 2
\&       my $q = new CGI;
\&       print $q->header;
.Ve
.PP
.Vb 36
\&       my $Form = HTML::FormEngine->new(scalar $q->Vars);
\&       my @form = (
\&            {
\&              templ => 'select',
\&              NAME => 'Salutation',
\&              OPTION => ['mr.','mrs.'],
\&            },
\&            {
\&             SIZE => 10,
\&             MAXLEN => 20,
\&             SUBTITLE => [['', '&nbsp;/&nbsp;']],
\&             NAME => [['forname', 'surname']],
\&             TITLE => 'For- / Surname ',
\&             ERROR_IN => 'not_null'
\&            },
\&            {
\&              MAXLEN => 30,
\&              NAME => 'Email',
\&              ERROR => ['not_null', 'rfc822'] # rfc822 defines the email address standard
\&            },
\&            {
\&             templ => 'radio',
\&             TITLE => 'Subscribe to newsletter?',
\&             NAME => 'newsletter',
\&             OPT_VAL => [[1, 2, 3]],
\&             OPTION => [['Yes', 'No', 'Perhaps']],
\&             VALUE => 1
\&            },
\&            {
\&             templ => 'check',
\&             OPTION => 'I agree to the terms of condition!',
\&             NAME => "agree",
\&             TITLE => '',
\&             ERROR => sub{ return("you've to agree!") if(! shift); }
\&            }
\&       );
.Ve
.PP
.Vb 2
\&       $Form->conf(\e@form);
\&       $Form->make();
.Ve
.PP
.Vb 7
\&       print $q->start_html('FormEngine example: Registration');
\&       if($Form->ok){
\&         $Form->clear();        
\&         print "<center>You've successfully subscribed!</center><br>";
\&       }
\&       print $Form->get,
\&             $q->end_html;
.Ve
.Sh "Example Output"
.IX Subsection "Example Output"
This output is produced by FormEngine when using the example code and no data was submitted:
.PP
.Vb 7
\&    <form action="/cgi-bin/FormEngine/registration.cgi" method="post">
\&    <table border=0 align="center" summary="">
\&    <tr>
\&       <td valign="top">Salutation</td>
\&       <td>
\&          <select size="1" name="Salutation">
\&            <option value="mr.">mr.</option>
.Ve
.PP
.Vb 9
\&            <option value="mrs.">mrs.</option>
\&          </select>
\&       </td>
\&       <td style="color:#FF0000" valign="bottom"></td>
\&    </tr>
\&    <tr>
\&       <td valign="top">For- / Surname </td>
\&       <td>
\&          <table border=0 cellspacing=0 cellpadding=0 summary="">
.Ve
.PP
.Vb 9
\&            <tr>
\&              <td valign="top">
\&                <table border=0 cellspacing=0 cellpadding=0 summary="">
\&                  <tr>
\&                    <td></td>
\&                    <td>
\&                      <input type="text" value="" name="forname" maxlength="20" size="10" /><br/>
\&                    </td>
\&                  </tr>
.Ve
.PP
.Vb 8
\&                  <tr><td></td><td style="color:#FF0000"></td></tr>
\&                </table>
\&              </td>
\&              <td valign="top">
\&                <table border=0 cellspacing=0 cellpadding=0 summary="">
\&                  <tr>
\&                    <td>&nbsp;/&nbsp;</td>
\&                    <td>
.Ve
.PP
.Vb 18
\&                      <input type="" value="" name="surname" maxlength="20" size="10" /><br/>
\&                    </td>
\&                  </tr>
\&                  <tr><td></td><td style="color:#FF0000"></td></tr>
\&                </table>
\&              </td>
\&            </tr>
\&          </table>
\&       </td>
\&       <td style="color:#FF0000" valign="bottom"></td>
\&    </tr>
\&    <tr>
\&       <td valign="top">Email</td>
\&       <td>
\&          <table border=0 cellspacing=0 cellpadding=0 summary="">
\&            <tr>
\&              <td valign="top">
\&                <table border=0 cellspacing=0 cellpadding=0 summary="">
.Ve
.PP
.Vb 9
\&                  <tr>
\&                    <td></td>
\&                    <td>
\&                      <input type="text" value="" name="Email" maxlength="30" size="20" /><br/>
\&                    </td>
\&                  </tr>
\&                  <tr><td></td><td style="color:#FF0000"></td></tr>
\&                </table>
\&              </td>
.Ve
.PP
.Vb 9
\&            </tr>
\&          </table>
\&       </td>
\&       <td style="color:#FF0000" valign="bottom"></td>
\&    </tr>
\&    <tr>
\&       <td valign="top">Subscribe to newsletter?</td>
\&       <td>
\&          <table border=0 summary="">
.Ve
.PP
.Vb 17
\&            <tr>
\&              <td><input type="radio" value="1" name="newsletter" checked />Yes</td>
\&              <td><input type="radio" value="2" name="newsletter" />No</td>
\&              <td><input type="radio" value="3" name="newsletter" />Perhaps</td>
\&            </tr>
\&          </table>
\&       </td>
\&       <td style="color:#FF0000" valign="bottom"></td>
\&    </tr>
\&    <tr>
\&       <td valign="top"></td>
\&       <td>
\&         <table summary="">
\&           <tr>
\&             <td>
\&               <input type="checkbox" value="I agree to the terms of condition!" name="agree" /> I agree to the terms of condition!
\&               <font style="color:#FF0000"></font>
.Ve
.PP
.Vb 13
\&             </td>
\&           </tr>
\&         </table>
\&       </td>
\&       <td valign="bottom" style="color:#FF0000"></td>
\&    </tr>
\&    <tr>
\&       <td align="right" colspan=3>
\&          <input type="submit" value="Ok" name="FormEngine" />
\&       </td>
\&    </tr>
\&    </table>
\&    </form>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
FormEngine.pm is a Perl 5 object class which provides an api for managing html/xhtml forms. FormEngine has its own, very flexible template system for defining form skins. A default skin is provided, it should be sufficent in most cases, but making your own isn't difficult (please send them to me!).
.PP
FormEngine also provides a set of functions for checking the form input, here too it is very easy to define your own check methods or to adapt the given.
.PP
\&\fIgettext\fR is used for international error message support. So use \f(CW\*(C`setlocale(LC_MESSAGES, 'german')\*(C'\fR if you want to have german error messages (there isn't support for any other language yet, but it shouldn't be difficult to translate the .po file, don't hesitate!).
.PP
Another usefull feature is the \f(CW\*(C`confirm\*(C'\fR method, which forces the user to read through his input once again before submitting it.
.PP
FormEngine is designed to make extension writing an easy task!
.SH "OVERVIEW"
.IX Header "OVERVIEW"
Start with calling the \f(CW\*(C`new\*(C'\fR method, it will return an FormEngine object. As argument you can pass a reference to an hash, which should contain the input values (calling \f(CW\*(C`set_input\*(C'\fR is also possible). Now you should define an array or hash which contains the form configuration. Pass a reference to that hash or array to \f(CW\*(C`conf\*(C'\fR. Now call \f(CW\*(C`make\*(C'\fR, this will generate the html code. Next you should use \f(CW\*(C`ok\*(C'\fR to check if the form was submitted and all input values are correct. If this is the case, you should display a success message and call \f(CW\*(C`get_input(fieldname)\*(C'\fR for getting the value of a certain field and e.g. write it in a database. Else you should call \f(CW\*(C`get\*(C'\fR (which will return the html form code) or \f(CW\*(C`print\*(C'\fR which will directly print the form.
.PP
If you want the form to be always displayed, you can use \f(CW\*(C`clear\*(C'\fR to empty it (resp. display the defaults) when the transmission was successfull.
.SH "USING FORMENGINE"
.IX Header "USING FORMENGINE"
The easiest way to define your form is to create an array of hash references:
.PP
.Vb 35
\&    my @form = (
\&            {
\&              templ => 'select',
\&              NAME => 'Salutation',
\&              OPTION => ['mr.','mrs.'],
\&            },
\&            {
\&             SIZE => 10,
\&             MAXLEN => 20,
\&             SUBTITLE => [['', '&nbsp;/&nbsp;']],
\&             NAME => [['forname', 'surname']],
\&             TITLE => 'For- / Surname ',
\&             ERROR_IN => 'not_null'
\&            },
\&            {
\&              MAXLEN => 30,
\&              NAME => 'Email',
\&              ERROR => ['not_null', 'rfc822'] # rfc822 defines the email address standard
\&            },
\&            {
\&             templ => 'radio',
\&             TITLE => 'Subscribe to newsletter?',
\&             NAME => 'newsletter',
\&             OPT_VAL => [[1, 2, 3]],
\&             OPTION => [['Yes', 'No', 'Perhaps']],
\&             VALUE => 1
\&            },
\&            {
\&             templ => 'check',
\&             OPTION => 'I agree to the terms of condition!',
\&             NAME => "agree",
\&             TITLE => '',
\&             ERROR => sub{ return("you've to agree!") if(! shift); }
\&            }
\&       );
.Ve
.PP
This is taken out of the example above. The \fItempl\fR key defines the field type (resp. template), the capital written keys are explained below. If \fItempl\fR is not defined, it is expected to be \f(CW\*(C`text\*(C'\fR.
.PP
You then pass a reference to that array to the \f(CW\*(C`conf\*(C'\fR method like this:
.PP
.Vb 1
\&       $Form->conf(\e@form);
.Ve
.PP
Another possibility is to define a hash of hash references and pass a reference on that to \f(CW\*(C`conf\*(C'\fR. This is seldom needed, but has the advantage that you can define low level variables:
.PP
.Vb 8
\&       my %form = (
\&            METHOD => 'get',
\&            FORMNAME => 'myform',
\&            SUBMIT => 'Yea! I want that!',
\&            'sub' => [ 
\&                        # Here you place your form definition (see above)
\&                     ] 
\&       );
.Ve
.PP
.Vb 1
\&       $Form->conf(\e%form);
.Ve
.PP
The meaning of the keys is explained below.
You can call \f(CW\*(C`set_main_vars\*(C'\fR for setting low level (main) variables as well, so the hash notation isn't necessary.
.Sh "The Default Skin (FormEngine)"
.IX Subsection "The Default Skin (FormEngine)"
Normally it is no problem to call the same template with the same name several times in one form (except \f(CW\*(C`check_uniq\*(C'\fR), but it might cause problems if you use the same name in diffrent templates.
.PP
The following field types are known by the default skin:
.IP "\(bu" 4
\&\fBtext\fR \- text input field(s), one row
.IP "\(bu" 4
\&\fBtextarea\fR \- text input field(s), several rows
.IP "\(bu" 4
\&\fBradio\fR \- selection list in terms of buttons (one can be selected)
.IP "\(bu" 4
\&\fBselect\fR \- selection list in terms of a pull down menu (one can be selected)
.IP "\(bu" 4
\&\fBcheck\fR \- selection list in terms of buttons (several can be selected)
.Sp
Using this template, you must give every option a diffrent name: option1, option2 ...
.Sp
The Advantage is, that it enables you to use the same option-list in one form several times. You might need that if you e.g. want to administrate several users at once.
.IP "\(bu" 4
\&\fBcheck_uniq\fR \- selection list in terms of buttons (several can be selected)
.Sp
Using this template, you only have to give one name for all options, but you can't use this name again in the form. Normally, this doesn't matter and so you'll use this template instaed of \f(CW\*(C`check\*(C'\fR.
.IP "\(bu" 4
\&\fBhidden\fR \- invisible field(s), can be used for passing data
.IP "\(bu" 4
\&\fBprint\fR \- this template simply prints out the given value
.IP "\(bu" 4
\&\fBbutton\fR \- displays a button
.IP "\(bu" 4
\&\fBemb_text\fR \- text field, designed to be embedded (nested) in another template (see below)
.Sh "Variables"
.IX Subsection "Variables"
Note that if you don't use the default skin, things might be diffrent. But mostly only the layout changes.
A skin which doesn't fit to the following conventiones should have its own documentation.
.PP
These Variables are always available:
.IP "\(bu" 4
\&\fB\s-1NAME\s0\fR \- the form fields name (this must be passed to \f(CW\*(C`get_input\*(C'\fR for getting the complying value)
.IP "\(bu" 4
\&\fB\s-1TITLE\s0\fR \- the displayed title of the field, by default the value of \s-1NAME\s0
.IP "\(bu" 4
\&\fB\s-1VALUE\s0\fR \- the default (or initial) value of the field
.IP "\(bu" 4
\&\fB\s-1ERROR\s0\fR \- accepts name of an FormEngine check routine (see Config.pm and Checks.pm), an anonymous function or an reference to a named method. If an array reference is passed, a list of the above mentioned values is expected. FormEngine will then call these routines one after another until an errormessage is returned or the end of the list is reached.
.PP
These variables are available for the \f(CW\*(C`text\*(C'\fR and \f(CW\*(C`emb_text\*(C'\fR field type only:
.IP "\(bu" 4
\&\fB\s-1SIZE\s0\fR \- the physical length of the field (in characters) [default: 20]
.IP "\(bu" 4
\&\fB\s-1MAXLEN\s0\fR \- max. count of characters that can be put into the field [default: no limit]
.IP "\(bu" 4
\&\fB\s-1TYPE\s0\fR \- if set to \fIpassword\fR for each character a \fI*\fR is printed (instead of the character) [default: \fItext\fR]
.PP
These variables are available for selection field types (\f(CW\*(C`radio\*(C'\fR, \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`check\*(C'\fR) only:
.IP "\(bu" 4
\&\fB\s-1OPTION\s0\fR \- accepts an reference to an array with options
.IP "\(bu" 4
\&\fB\s-1OPT_VAL\s0\fR \- accepts an reference to an array with values for the options (by default the value of \s-1OPTION\s0 is used)
.PP
These variables are available for the \f(CW\*(C`textarea\*(C'\fR field type only:
.IP "\(bu" 4
\&\fB\s-1COLS\s0\fR \- the width of the text input area [default: 27]
.IP "\(bu" 4
\&\fB\s-1ROWS\s0\fR \- the height of the text input area [default: 10]
.PP
These variables are available for the \f(CW\*(C`button\*(C'\fR field type only:
.IP "\(bu" 4
\&\fB\s-1TYPE\s0\fR \- can be 'button', 'submit' or 'reset' [default: 'button']
.PP
These variables are so called \fImain variables\fR they can be set by using the hash notation (see above) or by calling \f(CW\*(C`set_main_vars\*(C'\fR (see below):
.IP "\(bu" 4
\&\fB\s-1ACTION\s0\fR \- the url of the page to which the form data should be submitted [default: \f(CW$ENV\fR{\s-1REQUEST_URI\s0}, that means: the script calls itself]. Normally it doesn't make sense to change this value, but when you use mod_perl, you should set it to '$r\->uri'.
.IP "\(bu" 4
\&\fB\s-1METHOD\s0\fR \- can be 'post' (transmit the data in \s-1HTTP\s0 header) or 'get' (transmit the data by appeding it to the url) [default: post].
.IP "\(bu" 4
\&\fB\s-1SUBMIT\s0\fR \- the text that should be displayed on the submit button [default: Ok]
.IP "\(bu" 4
\&\fB\s-1FORMNAME\s0\fR \- the string by which this form should be identified [default: FormEngine]. You must change this if you have more than one FormEngine-made form on a page. Else FormEngine won't be able to distinguish which form was submitted.
.PP
\&\fBNote\fR: only \s-1NAME\s0 must be set, all other variables are optional.
.Sh "Methods For Creating Forms"
.IX Subsection "Methods For Creating Forms"
\fInew ([ \s-1HASHREF\s0 ])\fR
.IX Subsection "new ([ HASHREF ])"
.PP
This method is the constructor. It returns an FormEngine object.
You can pass the user input in a hash reference to it,
but you can use \f(CW\*(C`set_input\*(C'\fR as well.
.PP
\fIset_input ( \s-1HASHREF\s0 )\fR
.IX Subsection "set_input ( HASHREF )"
.PP
To this method you must pass a reference to a hash with input values.
You can pass this hash reference to the constructor (\f(CW\*(C`new\*(C'\fR) as well, then you don't
need this function.
If you use mod_perl you can get this reference by calling 'scalar \f(CW$m\fR\->request_args'.
If you use \s-1CGI\s0.pm you get it by calling 'scalar \f(CW$q\fR\->Vars'.
.PP
\fIconf ( \s-1FORMCONF\s0 )\fR
.IX Subsection "conf ( FORMCONF )"
.PP
You have to pass the configuration of your form as array or hash reference (see above).
.PP
\fIset_main_var ( \s-1HASHREF\s0 )\fR
.IX Subsection "set_main_var ( HASHREF )"
.PP
You can use this method for setting the values of the \fImain\fR template
variables (e.g. \s-1SUBMIT\s0).
Another possibility to do that is using the hash notation when configuring
the form (see above).
.PP
\fIclear\fR
.IX Subsection "clear"
.PP
If the form was submitted, this method simply calls \f(CW\*(C`set_use_input\*(C'\fR and \f(CW\*(C`set_error_chk\*(C'\fR. It
sets both to false.
If make was already called, it calls it again, so that no input is used and no error check 
is done.
.PP
\fIset_error_chk ( \s-1VALUE\s0 )\fR
.IX Subsection "set_error_chk ( VALUE )"
.PP
Sets wether the error handler should be called or not.
Default is true (1).
.PP
\fIset_use_input ( \s-1VALUE\s0 )\fR
.IX Subsection "set_use_input ( VALUE )"
.PP
Sets wether the given input should be displayed in the form fields or not.
Default is true (1).
.PP
\fImake\fR
.IX Subsection "make"
.PP
Creates the html/xhtml output, but doesn't return it (see \f(CW\*(C`get\*(C'\fR and \f(CW\*(C`print\*(C'\fR below).
Every method call which influences this output must be called before calling make!
.PP
\fIprint\fR
.IX Subsection "print"
.PP
Sends the html/xhtml output directly to \s-1STDOUT\s0. \f(CW\*(C`make\*(C'\fR must be called first!
.PP
\fIget\fR
.IX Subsection "get"
.PP
Returns the html/xhtml form code in a string. \f(CW\*(C`make\*(C'\fR must be called first!
.PP
\fIok\fR
.IX Subsection "ok"
.PP
Returns true (1) if the form was submitted and no errors were found!
Else it returns false (0).
This method simply calls \f(CW\*(C`is_submitted\*(C'\fR and \f(CW\*(C`get_error_count\*(C'\fR.
.PP
\fIget_error_count\fR
.IX Subsection "get_error_count"
.PP
Returns the count of errors which where found by the error handler.
.PP
\fIis_submitted\fR
.IX Subsection "is_submitted"
.PP
Returns true (1) if the form was submitted, false (0) if not.
.PP
\fIget_input ( \s-1FIELDNAME\s0 )\fR
.IX Subsection "get_input ( FIELDNAME )"
.PP
Returns the input value of the corresponding field.
.PP
\fIconfirm ( [\s-1CONFIRMMSG\s0] )\fR
.IX Subsection "confirm ( [CONFIRMMSG] )"
.PP
Calling this method will print the users input data and ask him to klick 'Ok' or 'Cancel'. 'Ok' will submit the data once again and then \f(CW\*(C`is_confirmed\*(C'\fR will return true (1). 'Cancel' will display the form, so that the user can change the data.
.PP
By default the message defined in \fIConfig.pm\fR will be displayed, but you can also pass your own text.
.PP
\fIis_confirmed\fR
.IX Subsection "is_confirmed"
.PP
This method returns true (1) when the form input was affirmed by the user
(see \f(CW\*(C`confirm\*(C'\fR method).
.Sh "Methods For Configuring FormEngine"
.IX Subsection "Methods For Configuring FormEngine"
\fIset_skin ( \s-1NAME\s0 )\fR
.IX Subsection "set_skin ( NAME )"
.PP
If you want to use an alternate skin, call this method.
You have to pass the name of an registered skin (see Config.pm).
.PP
\fIadd_skin ( \s-1HASHREF\s0 )\fR
.IX Subsection "add_skin ( HASHREF )"
.PP
If you only want to add or overwrite some templates of the current
skin, call this method.
You have to pass a reference to the hash which stores these templates.
.PP
\fIset_default ( \s-1HASHREF\s0 )\fR
.IX Subsection "set_default ( HASHREF )"
.PP
By using this method, you completly reset the default values of the
template variables. You have to pass a reference to the hash which
stores the new settings. Look at Config.pm to see the current
settings. In most cases you better call \f(CW\*(C`add_default\*(C'\fR.
.PP
\fIadd_default ( \s-1HASHREF\s0 )\fR
.IX Subsection "add_default ( HASHREF )"
.PP
Pass a hash reference to this method for adding or overwriting default
values. Look at Config.pm for more information.
.PP
\fIset_handler ( \s-1HASHREF\s0 )\fR
.IX Subsection "set_handler ( HASHREF )"
.PP
This method resets the handler settings. Look at Config.pm for the
default settings. If you just want to add or overwrite a handler setting, 
use \f(CW\*(C`add_handler\*(C'\fR (see below).
.PP
\fIadd_handler ( \s-1HASHREF\s0 )\fR
.IX Subsection "add_handler ( HASHREF )"
.PP
This method adds or overwrites template handlers. Look at Config.pm and
Handler.pm for more information.
.PP
\fIadd_checks ( \s-1HASHREF\s0 )\fR
.IX Subsection "add_checks ( HASHREF )"
.PP
This method temporary adds or overwrites check routines. Look at Config.pm and
Checks.pm for more information.
.PP
\fIset_confirm_skin ( \s-1HASHREF\s0 )\fR
.IX Subsection "set_confirm_skin ( HASHREF )"
.PP
The confirm method replaces the form-templates with confirm\-templates.
The default replacements are defined in Config.pm. For Example the \f(CW\*(C`main\*(C'\fR template is replaced by the \f(CW\*(C`confirm\*(C'\fR template. The defaults are still taken from the original templates.
.PP
The special key \fIdefault\fR defines the template, which will be used when for a certain form-template no confirm-template was defined.
.PP
So the referenced hash, which you must pass to this method, has to look like this:
.PP
.Vb 5
\& FORM_TEMPLATE_NAME => CONFIRM_TEMPLATE_NAME,
\& FORM_TEMPLATE_NAME => CONFIRM_TEMPLATE_NAME,
\& .
\& .
\& .
.Ve
.PP
\fIadd_confirm_skin ( \s-1HASHREF\s0 )\fR
.IX Subsection "add_confirm_skin ( HASHREF )"
.PP
With this method, you can update the current confirm skin settings.
For more information see above.
.PP
\fIset_confirm_handler ( \s-1HASHREF\s0 )\fR
.IX Subsection "set_confirm_handler ( HASHREF )"
.PP
Sometimes, it might make sense to call a special confirm handler instead of the really referenced one.
So the referenced hash must assign a handler method to a handler\- or template name.
.PP
\fIadd_confirm_handler ( \s-1HASHREF\s0 )\fR
.IX Subsection "add_confirm_handler ( HASHREF )"
.PP
With this method, you can update the current confirm handler settings.
For more information see above.
.Sh "Debug Methods"
.IX Subsection "Debug Methods"
\fIset_debug ( \s-1DEBUGLEVEL\s0 )\fR
.IX Subsection "set_debug ( DEBUGLEVEL )"
.PP
Sets the debug level. The higher the value the more output is printed.
.PP
\fIget_method\fR
.IX Subsection "get_method"
.PP
Returns the value of \fImain\fRs \s-1METHOD\s0 variable (should be \fIget\fR or \fIpost\fR).
.PP
\fIget_formname\fR
.IX Subsection "get_formname"
.PP
Returns the value of \fImain\fRs \s-1FORMNAME\s0 variable. If you have several
FormEngine forms on one page, these forms mustn't have the same \s-1FORMNAME\s0 value!
You can set it with \f(CW\*(C`set_main_vars\*(C'\fR.
.PP
\fIget_conf\fR
.IX Subsection "get_conf"
.PP
Returns a reference to a hash with the current form configuration.
Changing this hash \s-1DOESN\s0'T influence the configuration, because it
is just a copy.
.PP
\fIprint_conf ( \s-1HASHREF\s0 )\fR
.IX Subsection "print_conf ( HASHREF )"
.PP
Prints the given form configuration to \s-1STDOUT\s0.
.Sh "Special Features"
.IX Subsection "Special Features"
\fInesting templates\fR
.IX Subsection "nesting templates"
.PP
There are two ways how you can nest templates. The first one
is to put a handler call in the template definition. This is a less flexible
solution, but it might be very usefull. See the \s-1POD\s0 of Skin.pm
for more information.
.PP
The second and flexible way is, to assign a handler call to a template variable
(see the \s-1POD\s0 of Skin.pm for more information about handler calls).
A good example for this way is hobbies.cgi. There you have a option called \fIother\fR
and an input field to put in the name of this alternative hobby. When you look at
the form definition below, you see that the value of the \fI\s-1OPTION\s0\fR variable of this option
is simply \fI<&emb_text&\fR>, this is a handler call. So the handler is called and its
return value (in this case the processed emb_text template) is assigned to the variable.
.PP
The form definition of hobbies.cgi:
.PP
.Vb 12
\&    my @form = (
\&            {
\&              templ => 'check',
\&              NAME  => [['hobbies1','hobbies2'],['hobbies3','hobbies4'],['hobbies5','hobbies6'],'hobbies7','hobbies8'],
\&              TITLE => 'hobbies',
\&              OPTION => [['Parachute Jumping', 'Playing Video Games'], ['Doing Nothing', 'Soak'], ['Head Banging', 'Cat Hunting'], "Don't Know", '<&emb_text&>'],
\&              OPT_VAL => [[1,2], [3,4], [5,6], 7, 8],
\&              VALUE => [1,2,7],
\&              'sub' => {'emb_text' => {'NAME' => 'Other', 'VALUE' => ''}},
\&              ERROR => sub{if(shift eq 4) { return "That's not a faithfull hobby!" }}
\&            }
\&    );
.Ve
.PP
If you have a closer look at the form definition above, you'll recognize that there
is a key called 'sub'. With help of this key you can define the 
variables of the nested templates. If the nested templates don't use the same variable
names as their parents, you don't need that, because then you can assign these variables on the same
level with the parents template variables. 
.SH "EXTENDING FORMENGINE"
.IX Header "EXTENDING FORMENGINE"
.Sh "Modify A Skin"
.IX Subsection "Modify A Skin"
To modify the current skin, use the method \f(CW\*(C`add_skin\*(C'\fR (see above). You should
have a look at Skin.pm and read its \s-1POD\s0.
.Sh "Write A New Skin"
.IX Subsection "Write A New Skin"
Have a look at Skin.pm for this task. You can easily change the layout
by copying the skin hash, fitting the html code to your needs and then using
\&\f(CW\*(C`set_skin\*(C'\fR (see above) to overwrite the default.
Please send me your skins.
.Sh "Write A Handler"
.IX Subsection "Write A Handler"
Look at the \s-1POD\s0 of Handler.pm. You can use \f(CW\*(C`add_handler\*(C'\fR to 
add your handler temporary, edit Config.pm to make it persistent.
.Sh "Write A Check Routine"
.IX Subsection "Write A Check Routine"
The design of a check routine is explained in the \s-1POD\s0 of Checks.pm.
You can easily refer to it by reference or even define it in line as an anonymous function (see
the \s-1ERROR\s0 template variable).
If your new written routine is of general usage, you should make it part of FormEngine by placing
it in Checks.pm and refering to it in Config.pm. Please send me such methods!
.SH "MORE INFORMATION"
.IX Header "MORE INFORMATION"
Have a look at ...
.IP "\(bu" 4
the \s-1POD\s0 of Skin.pm for information about FormEngines template system.
.IP "\(bu" 4
the \s-1POD\s0 of Handler.pm for information about FormEngines handler architecture.
.IP "\(bu" 4
the \s-1POD\s0 of Checks.pm for information about FormEngines check methods.
.IP "\(bu" 4
Config.pm for the default configuration.
.SH "BUGS"
.IX Header "BUGS"
Send bug reports to: moritz@freesources.org
.PP
Thanks!
.SH "AUTHOR"
.IX Header "AUTHOR"
(c) 2003, Moritz Sinn. This module is free software; you can redistribute it and/or modify it under the terms of the \s-1GNU\s0 General Public License (see http://www.gnu.org/licenses/gpl.txt) as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.
.PP
.Vb 4
\&    This module is distributed in the hope that it will be useful,
\&    but WITHOUT ANY WARRANTY; without even the implied warranty of
\&    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\&    GNU General Public License for more details.
.Ve
.PP
I am always interested in knowing how my work helps others, so if you put this module to use in any of your own code then please send me the \s-1URL\s0. Also, if you make modifications to the module because it doesn't work the way you need, please send me a copy so that I can roll desirable changes into the main release.
.PP
Address comments, suggestions, and bug reports to moritz@freesources.org. 
.SH "CREDITS"
.IX Header "CREDITS"
Special thanks go to Darren Duncan. His HTML::FormTemplate module gave me a good example how to write a documentation. There are several similarities between HTML::FormEngine and HTML::FormTemplate, we both came to an related \s-1API\s0 design, the internal processes are completly diffrent. It wasn't my purpose to have these api design decisions in common with HTML::FormTemplate. When i wrote the php version of HTML::FormEngine, i didn't know anything about HTML::FormTemplate. Later i just ported this php class to perl. I think we both came to an likewise \s-1API\s0 because its just the most obvious solution.
.PP
Features which FormEngine has and FormTemplate hasn't:
.IP "\(bu" 4
Skinsystem
.IP "\(bu" 4
More flexible validation and error message report
.IP "\(bu" 4
Common checking methods are predefined, others can be added on the fly
.IP "\(bu" 4
Internationalization with help of gettext
.IP "\(bu" 4
Adaptation through Config.pm
.IP "\(bu" 4
Due to the handler system and the modular design FormEngine can easily
be extended
.IP "\(bu" 4
A flexible set of methods to let the user confirm his input
.PP
Features which FormTemplate has and FormEngine hasn't:
.PP
\&\fIThis list will be filled in later.\fR
.PP
(I ask the author to send me some notes, he told me he'll do so at opportunity.)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
HTML::FormTemplate by Darren Duncan
