.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FormEngine::Checks 3"
.TH FormEngine::Checks 3 "2003-03-03" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
HTML::FormEngine::Checks \- collection of FormEngine check routines
.SH "CHECK ROUTINES"
.IX Header "CHECK ROUTINES"
.Sh "not_null"
.IX Subsection "not_null"
Returns \fIvalue missing\fR if the field wasn't filled.
.Sh "check_email"
.IX Subsection "check_email"
Returns \fIinvalid\fR if the format of the field value seems to be
incompatible to an email address. Here a simple regular expression 
is used, which so far matches the common email addresses. But it isn't
compatible to any standard. Use \f(CW\*(C`rfc822\*(C'\fR if you want to check for \s-1RFC\s0
compatible address format. The problem with rfc is, that some working
addresses don't fit to it, though these are very rare
.PP
Here is the used regexp, please inform me if you discover any bugs:
.PP
\&\f(CW\*(C`^[A\-Za\-z0\-9._\-]+@[a\-zA\-Z0\-9.\-]+\e.[a\-zA\-Z]{2,6}$\*(C'\fR
.Sh "rfc822"
.IX Subsection "rfc822"
Returns \fIrfc822 failure\fR if the given field value doesn't match the \s-1RFC\s0 822
specification. In \s-1RFC\s0 822 the format of valid email addresses is defined.
This check routine is somewhat better than \fIemail\fR, the only disadvantage
is, that some working email addresses don't fit to \s-1RFC\s0 822. So if you get
problems try using the <email> routine.
.PP
I copied this routine from http://www.cpan.org/authors/Tom_Christiansen/scripts/ckaddr.gz!
.Sh "date"
.IX Subsection "date"
Returns \fIinvalid\fR if the field value seems to be incompatible to common
date formats or the date doesn't exist in the Gregorian calendar.
The following formats are allowed:
.PP
dd.mm.yyyy dd-mm-yyyy dd/mm/yyyy
yyyy-mm-dd yyyy/mm/dd yyyy.mm.dd
.PP
The \f(CW\*(C`check_date\*(C'\fR method of the \fIDate::Pcalc\fR package is used to prove
the dates existence.
.Sh "digitonly"
.IX Subsection "digitonly"
\&... returns \fIinvalid\fR if the value doesn't match '[0\-9]*'.
.Sh "fmatch"
.IX Subsection "fmatch"
\&... requires the special variable \fIfmatch\fR. This variable must
contain the name of another field. The value of this field is read in
and compared with the current value, \fIdoesn't match\fR is returned if
this fails.
.PP
When using the same fields several times, you must also define
\&\fI\s-1ROWNUM\s0\fR, this must start with 1 increased by one whenever the field
names are repeated.
.Sh "regex"
.IX Subsection "regex"
\&... requires the special variable \fIregex\fR, it must contain a valid
regular expression. If the value doesn't match this regex, \fIinvalid\fR
is returned. 
.SH "WRITING A CHECK ROUTINE"
.IX Header "WRITING A CHECK ROUTINE"
.Sh "Design"
.IX Subsection "Design"
In general, a check routine has the following structure:
.PP
.Vb 5
\&  sub mycheck {
\&    my($value,$name,$self) = @_;
\&    #some lines of code#
\&    return gettext('My ErrorMessage');
\&  }
.Ve
.PP
\&\f(CW$value\fR contains the submitted field value.
\&\f(CW$name\fR contains the fields name.
\&\f(CW$self\fR contains a reference to the FormEngine object.
.PP
\&\fBNote:\fR you can define the error message by yourself with the variable \fIerrmsg\fR!
.Sh "Install"
.IX Subsection "Install"
If your routine does a general job, you can make it part of FormEngine. Therefore just
add the routine to this file and refer to it from \fIConfig.pm\fR. Please send me such
routines.
.SH "ERROR MESSAGE TRANSLATIONS"
.IX Header "ERROR MESSAGE TRANSLATIONS"
The translations of the error messages are stored in \fIFormEngine.po\fR files. Calling
\&\fImsgfmt\fR translates these in \fIFormEngine.mo\fR files. You must store these FormEngine.mo files in your
locale directory, this should be \fI/usr/share/locale\fR, if it isn't, you must change the value
of \f(CW$textdomain\fR in Config.pm.
.PP
Provided that a translation for \fIyourlanguage\fR exists, you can call \f(CW\*(C`setlocale(LC_MESSAGES, 'yourlanguage')\*(C'\fR in your script to have the FormEngine error message in \fIyourlanguage\fR.
